<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>문서관리 테스트</title>
    <script src="https://cdn.jsdelivr.net/npm/showdown@1.9.1/dist/showdown.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            background-color: #f9f9f9;
        }
        .sidebar, .toc-sidebar {
            width: 25%;
            min-width: 250px;
            max-width: 300px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            height: 100vh;
        }
        .content {
            flex-grow: 1;
            padding: 20px;
            background-color: #fff;
            overflow-y: auto;
            box-sizing: border-box;
        }
        ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        li {
            margin: 5px 0;
        }
        .folder {
            font-weight: bold;
            cursor: pointer;
        }
        .folder::before {
            content: '▶';
            margin-right: 5px;
            display: inline-block;
            transition: transform 0.2s ease-in-out;
        }
        .folder.open::before {
            transform: rotate(90deg);
        }
        .folder ul {
            margin-left: 20px;
            display: none;
        }
        .folder.open ul {
            display: block;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }
        table th, table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        table th {
            background-color: #f4f4f4;
        }
        @media screen and (max-width: 768px) {
            .sidebar, .toc-sidebar {
                width: 100%;
                height: auto;
                box-shadow: none;
            }
            .content {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>Version</h2>
        <select id="version-selector"></select>

        <h2>Language</h2>
        <select id="language-selector">
            <option value="en">English</option>
            <option value="ko">한글</option>
        </select>

        <h2>Documents</h2>
        <ul id="document-list"></ul>
    </div>

    <div class="content">
        <h1>문서 관리 테스트</h1>
        <div id="markdown-container">문서를 선택하세요</div>
    </div>

    <div class="toc-sidebar">
        <h2>Table of Contents</h2>
        <ul id="toc-list"></ul>
    </div>

    <script>
        const repoOwner = "OmniOneID";
        const repoName = "did-doc-architecture";
        const documentList = document.getElementById("document-list");
        const markdownContainer = document.getElementById("markdown-container");
        const tocList = document.getElementById("toc-list");
        const versionSelector = document.getElementById("version-selector");
        const languageSelector = document.getElementById("language-selector");

        let selectedLanguage = "en";

        async function fetchBranches() {
            const url = `https://api.github.com/repos/${repoOwner}/${repoName}/branches`;
            const response = await fetch(url);
            return await response.json();
        }

        async function fetchMarkdownFiles(branch) {
            const url = `https://api.github.com/repos/${repoOwner}/${repoName}/git/trees/${branch}?recursive=1`;
            const response = await fetch(url);
            const data = await response.json();
            const mdFiles = data.tree.filter(item => {
                const isTargetLanguage = selectedLanguage === "ko" 
                    ? item.path.endsWith("_ko.md") 
                    : item.path.endsWith(".md") && !item.path.endsWith("_ko.md");
                return isTargetLanguage && !item.path.startsWith("root/") && !item.path.startsWith("docs/") && !item.path.startsWith("./github/");
            });

            const folders = {};
            mdFiles.forEach(item => {
                const parts = item.path.split("/");
                const folder = parts.slice(0, -1).join("/");
                if (!folders[folder]) folders[folder] = [];
                folders[folder].push(item);
            });

            return Object.entries(folders).filter(([_, files]) => files.length > 0);
        }

        async function fetchFileContent(filePath) {
            const branch = versionSelector.value;
            const url = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/${branch}/${filePath}`;
            const response = await fetch(url);
            return await response.text();
        }

        async function getMarkdownTitle(filePath) {
            const content = await fetchFileContent(filePath);
            const match = content.match(/^#\s+(.*)/m);
            return match ? match[1].trim() : filePath.split("/").pop().replace(/_/g, " ");
        }

        async function renderMarkdown(filePath) {
            const content = await fetchFileContent(filePath);
            const processedContent = content.replace(/!\[.*?\]\((.*?)\)/g, (match, p1) => {
                const branch = versionSelector.value;
                // 수정: 이미지 경로를 상대경로로 변환하여 GitHub URL로 처리
                const imageUrl = p1.startsWith("http") ? p1 : `https://raw.githubusercontent.com/${repoOwner}/${repoName}/${branch}/${p1}`;
                return `![Image](${imageUrl})`;
            });
            const converter = new showdown.Converter({ tables: true });
            markdownContainer.innerHTML = converter.makeHtml(processedContent);
            renderToc(content);
        }

        function renderToc(content) {
            tocList.innerHTML = "";
            const lines = content.split("\n");
            lines.forEach((line, index) => {
                const match = line.match(/^(#{1,6})\s+(.*)/);
                if (match) {
                    const [, hashes, title] = match;
                    const li = document.createElement("li");
                    li.style.marginLeft = `${(hashes.length - 1) * 20}px`;

                    const link = document.createElement("a");
                    link.textContent = title;
                    link.href = `#section-${index}`;
                    link.addEventListener("click", (e) => {
                        e.preventDefault();
                        document.getElementById(`section-${index}`).scrollIntoView({ behavior: "smooth" });
                    });

                    li.appendChild(link);
                    tocList.appendChild(li);

                    const section = document.createElement("div");
                    section.id = `section-${index}`;
                    section.style.marginTop = "-60px";
                    section.style.paddingTop = "60px";
                    markdownContainer.appendChild(section);
                }
            });
        }

        async function populateDocumentList(branch) {
            const folders = await fetchMarkdownFiles(branch);
            documentList.innerHTML = "";

            for (const [folder, files] of folders) {
                const folderLi = document.createElement("li");
                folderLi.classList.add("folder");
                folderLi.textContent = folder || "Root";
                folderLi.addEventListener("click", () => {
                    const subList = folderLi.querySelector("ul");
                    const isOpen = subList.style.display === "block";
                    subList.style.display = isOpen ? "none" : "block";
                    folderLi.classList.toggle("open", !isOpen);
                });

                const subList = document.createElement("ul");
                subList.style.display = "none";

                for (const file of files) {
                    const fileTitle = await getMarkdownTitle(file.path);
                    const fileLi = document.createElement("li");
                    const fileLink = document.createElement("a");
                    fileLink.textContent = fileTitle;
                    fileLink.href = "#";
                    fileLink.addEventListener("click", async (e) => {
                        e.preventDefault();
                        await renderMarkdown(file.path);
                    });
                    fileLi.appendChild(fileLink);
                    subList.appendChild(fileLi);
                }

                folderLi.appendChild(subList);
                documentList.appendChild(folderLi);
            }
        }

        async function initialize() {
            const branches = await fetchBranches();
            branches.forEach(branch => {
                const option = document.createElement("option");
                option.value = branch.name;
                option.textContent = branch.name;
                versionSelector.appendChild(option);
            });

            versionSelector.addEventListener("change", () => populateDocumentList(versionSelector.value));
            languageSelector.addEventListener("change", () => {
                selectedLanguage = languageSelector.value;
                populateDocumentList(versionSelector.value);
            });

            versionSelector.value = branches[0].name;
            await populateDocumentList(branches[0].name);
        }

        initialize();
    </script>
</body>
</html>
